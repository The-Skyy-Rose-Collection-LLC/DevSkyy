---
# DevSkyy Platform - Production Deployment Workflow
# FIXED: Image digest extraction after push for SLSA provenance

name: Deploy to Production

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write  # For SLSA provenance

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  REGION: us-central1
  PROJECT_ID: devskyy-production

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      image-digest: ${{ steps.push.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.version }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    # FIXED: Build and push in one step, capture digest from push output
    - name: Build and push Docker image
      id: push
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.production
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}
          VERSION=${{ steps.meta.outputs.version }}

    # FIXED: Extract digest from push output (not from docker inspect pre-push)
    - name: Set image digest output
      id: digest
      run: |
        echo "IMAGE_DIGEST=${{ steps.push.outputs.digest }}" >> $GITHUB_OUTPUT
        echo "Image pushed with digest: ${{ steps.push.outputs.digest }}"

    - name: Generate SBOM
      uses: anchore/sbom-action@v0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.push.outputs.digest }}
        format: cyclonedx-json
        output-file: sbom.json

    - name: Upload SBOM
      uses: actions/upload-artifact@v4
      with:
        name: sbom
        path: sbom.json
        retention-days: 90

  # FIXED: Use digest from build-and-push job output
  provenance:
    name: Generate SLSA Provenance
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      id-token: write
      contents: read
      packages: write

    steps:
    - name: Generate SLSA provenance
      uses: slsa-framework/slsa-github-generator/.github/workflows/generator_container_slsa3.yml@v1.9.0
      with:
        image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        # FIXED: Use digest from previous job output
        digest: ${{ needs.build-and-push.outputs.image-digest }}
        registry-username: ${{ github.actor }}
        registry-password: ${{ secrets.GITHUB_TOKEN }}

  deploy-cloud-run:
    name: Deploy to Google Cloud Run
    runs-on: ubuntu-latest
    needs: [build-and-push, provenance]
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 20

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: ${{ secrets.GCP_SA_KEY }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v2

    # FIXED: Run database migrations using Cloud Run Jobs (not local pip install)
    - name: Run database migrations
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-and-push.outputs.image-digest }}"

        # Check if manage.py exists before creating migration job
        if [ ! -f manage.py ]; then
          echo "WARNING: manage.py not found. Skipping migrations."
          exit 0
        fi

        # Create and execute Cloud Run job for migrations
        gcloud run jobs create devskyy-migrate-${{ github.run_id }} \
          --image "$IMAGE" \
          --region "${{ env.REGION }}" \
          --set-env-vars "DATABASE_URL=${{ secrets.DATABASE_URL }},ENVIRONMENT=production" \
          --task-timeout=600 \
          --execute-now \
          --wait \
          --command python \
          --args "manage.py,migrate,--noinput" || {
            echo "::warning::Migration job failed or timed out"
            exit 1
          }

        # Clean up migration job
        gcloud run jobs delete devskyy-migrate-${{ github.run_id }} \
          --region "${{ env.REGION }}" \
          --quiet || true

    - name: Deploy to Cloud Run
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-and-push.outputs.image-digest }}"

        gcloud run deploy devskyy \
          --image "$IMAGE" \
          --region "${{ env.REGION }}" \
          --platform managed \
          --allow-unauthenticated \
          --port 8000 \
          --cpu 2 \
          --memory 4Gi \
          --min-instances 1 \
          --max-instances 20 \
          --concurrency 100 \
          --timeout 300 \
          --set-env-vars "ENVIRONMENT=production" \
          --set-secrets "SECRET_KEY=devskyy-secret-key:latest,JWT_SECRET_KEY=devskyy-jwt-secret:latest,ENCRYPTION_MASTER_KEY=devskyy-encryption-key:latest,DATABASE_URL=devskyy-database-url:latest,REDIS_URL=devskyy-redis-url:latest"

    - name: Get Cloud Run URL
      id: url
      run: |
        URL=$(gcloud run services describe devskyy \
          --region "${{ env.REGION }}" \
          --format 'value(status.url)')
        echo "SERVICE_URL=$URL" >> $GITHUB_OUTPUT
        echo "Deployed to: $URL"

    - name: Smoke test deployment
      run: |
        sleep 10  # Wait for service to be ready
        curl -f -s -o /dev/null -w "%{http_code}" \
          "${{ steps.url.outputs.SERVICE_URL }}/health" || {
            echo "::error::Smoke test failed"
            exit 1
          }

  deploy-kubernetes:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [build-and-push, provenance]
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 20

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/k8s-set-context@v3
      with:
        kubeconfig: ${{ secrets.KUBE_CONFIG }}

    - name: Set up Kustomize
      run: |
        curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
        sudo mv kustomize /usr/local/bin/

    - name: Update image in kustomization
      working-directory: k8s/overlays/production
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
        TAG="${{ needs.build-and-push.outputs.image-tag }}"

        kustomize edit set image devskyy="$IMAGE:$TAG"

    - name: Deploy to Kubernetes
      run: |
        kubectl apply -k k8s/overlays/production
        kubectl rollout status deployment/devskyy -n devskyy --timeout=5m

    - name: Verify deployment
      run: |
        kubectl get pods -n devskyy
        kubectl get hpa -n devskyy
        kubectl get ingress -n devskyy

  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [deploy-cloud-run, deploy-kubernetes]
    if: always()

    steps:
    - name: Send deployment notification
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        text: |
          Deployment ${{ job.status }}
          Version: ${{ needs.build-and-push.outputs.image-tag }}
          Digest: ${{ needs.build-and-push.outputs.image-digest }}
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
