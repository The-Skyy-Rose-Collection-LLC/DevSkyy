> """
> WordPress AI-Powered Categorization Service
  
> WHY: Automatically categorize WordPress posts using AI for better organization
> HOW: Use Claude/GPT to analyze post titles and assign appropriate categories
> IMPACT: Improved content discovery and SEO through proper taxonomy
  
> Truth Protocol: Validated category IDs, explicit error handling, no placeholders
> """
  
! import logging
! from typing import Any, Optional
  
! import anthropic
! from openai import OpenAI
! from pydantic import BaseModel, Field
  
! from services.mcp_client import MCPToolClient, MCPToolError
  
  
! logger = logging.getLogger(__name__)
  
  
! class CategoryMapping(BaseModel):
!     """WordPress category mapping configuration"""
  
!     category_id: int = Field(..., description="WordPress category ID")
!     category_name: str = Field(..., description="Category display name")
!     description: str = Field(..., description="Category description for AI context")
!     keywords: list[str] = Field(default_factory=list, description="Relevant keywords")
  
  
! class CategorizationResult(BaseModel):
!     """Result of post categorization"""
  
!     post_id: int
!     post_title: str
!     assigned_category_id: int
!     assigned_category_name: str
!     confidence: float = Field(ge=0.0, le=1.0)
!     reasoning: Optional[str] = None
!     error: Optional[str] = None
  
  
! class WordPressCategorizationService:
!     """
!     AI-powered WordPress post categorization service
  
!     Features:
!     - Analyze post titles using AI
!     - Assign appropriate category from predefined list
!     - Batch processing support
!     - Confidence scoring
!     - Fallback to default category if uncertain
!     """
  
!     DEFAULT_CATEGORIES = [
!         CategoryMapping(
!             category_id=13,
!             category_name="Content Creation",
!             description="Posts about creating content, writing, blogging, copywriting",
!             keywords=[
!                 "content",
!                 "writing",
!                 "blog",
!                 "copywriting",
!                 "article",
!                 "storytelling",
!             ],
!         ),
!         CategoryMapping(
!             category_id=14,
!             category_name="Digital Marketing",
!             description="Posts about marketing strategies, SEO, social media marketing",
!             keywords=[
!                 "marketing",
!                 "seo",
!                 "social media",
!                 "advertising",
!                 "promotion",
!                 "branding",
!             ],
!         ),
!         CategoryMapping(
!             category_id=15,
!             category_name="AI Tools",
!             description="Posts about artificial intelligence tools, ChatGPT, AI applications",
!             keywords=["ai", "artificial intelligence", "chatgpt", "machine learning", "automation"],
!         ),
!         CategoryMapping(
!             category_id=17,
!             category_name="Automation & Integration",
!             description="Posts about workflow automation, integrations, n8n, Zapier",
!             keywords=[
!                 "automation",
!                 "integration",
!                 "workflow",
!                 "n8n",
!                 "zapier",
!                 "api",
!                 "webhook",
!             ],
!         ),
!         CategoryMapping(
!             category_id=18,
!             category_name="Productivity Tools",
!             description="Posts about productivity apps, time management, organization tools",
!             keywords=[
!                 "productivity",
!                 "efficiency",
!                 "tools",
!                 "apps",
!                 "time management",
!                 "organization",
!             ],
!         ),
!         CategoryMapping(
!             category_id=19,
!             category_name="Analytics & Strategy",
!             description="Posts about data analytics, metrics, business strategy, growth",
!             keywords=[
!                 "analytics",
!                 "metrics",
!                 "data",
!                 "strategy",
!                 "growth",
!                 "optimization",
!             ],
!         ),
!     ]
  
!     def __init__(
!         self,
!         anthropic_api_key: Optional[str] = None,
!         openai_api_key: Optional[str] = None,
!         categories: Optional[list[CategoryMapping]] = None,
!         default_category_id: int = 13,
!         use_mcp: bool = True,
!         mcp_client: Optional[MCPToolClient] = None,
!     ):
!         """
!         Initialize categorization service
  
!         WHY: Support both MCP and direct API calls for flexibility
!         HOW: Prefer MCP for token optimization, fallback to direct APIs
!         IMPACT: 98% token reduction when using MCP
  
!         Args:
!             anthropic_api_key: Anthropic API key (optional)
!             openai_api_key: OpenAI API key (optional)
!             categories: Custom category mappings (optional, uses defaults if not provided)
!             default_category_id: Fallback category if uncertain
!             use_mcp: Whether to use MCP tool calling (default: True)
!             mcp_client: Optional MCP client instance
!         """
!         self.use_mcp = use_mcp
!         self.mcp_client = mcp_client or (MCPToolClient() if use_mcp else None)
!         self.anthropic_client = None
!         self.openai_client = None
  
!         if anthropic_api_key:
!             self.anthropic_client = anthropic.Anthropic(api_key=anthropic_api_key)
!             logger.info("Anthropic client initialized for categorization")
  
!         if openai_api_key:
!             self.openai_client = OpenAI(api_key=openai_api_key)
!             logger.info("OpenAI client initialized for categorization")
  
!         if use_mcp:
!             logger.info("✅ Using MCP tool calling for categorization (98% token reduction)")
!         elif not self.anthropic_client and not self.openai_client:
!             logger.warning("⚠️  No AI provider configured - using keyword matching fallback")
  
!         self.categories = categories or self.DEFAULT_CATEGORIES
!         self.default_category_id = default_category_id
  
!         logger.info(f"WordPressCategorizationService initialized with {len(self.categories)} categories")
  
!     def _build_categorization_prompt(self, post_title: str) -> str:
!         """
!         Build AI prompt for categorization
  
!         Args:
!             post_title: Post title to categorize
  
!         Returns:
!             Formatted prompt
!         """
!         category_list = []
!         for cat in self.categories:
!             category_list.append(f"{cat.category_id} = {cat.category_name} - {cat.description}")
  
!         prompt = f"""You are an expert content strategist and taxonomy specialist with extensive experience in blog categorization and content organization.
  
! I will provide you with a blog post's title. Your task is to assign ONE primary category ID from this fixed list:
  
! {chr(10).join(category_list)}
  
! Analyze the title and return only the single most relevant category ID number that best represents the main focus of the post. While a post might touch on multiple topics, select the dominant theme that would be most useful for navigation purposes.
  
! Post Title: "{post_title}"
  
! Output format (JSON):
! {{
!   "category_id": <number>,
!   "confidence": <0.0-1.0>,
!   "reasoning": "<brief explanation>"
! }}
  
! Output only valid JSON."""
  
!         return prompt
  
!     async def categorize_with_anthropic(self, post_title: str) -> dict[str, Any]:
!         """
!         Categorize post using Anthropic Claude
  
!         Args:
!             post_title: Post title
  
!         Returns:
!             Dict with category_id, confidence, reasoning
!         """
!         if not self.anthropic_client:
!             raise ValueError("Anthropic client not initialized")
  
!         try:
!             prompt = self._build_categorization_prompt(post_title)
  
!             response = self.anthropic_client.messages.create(
!                 model="claude-sonnet-4-20250514",
!                 max_tokens=200,
!                 temperature=0.3,  # Lower temperature for more consistent categorization
!                 messages=[{"role": "user", "content": prompt}],
!             )
  
!             content = response.content[0].text
  
              # Parse JSON response
!             import json
  
              # Extract JSON from markdown code blocks if present
!             if "```json" in content:
!                 json_str = content.split("```json")[1].split("```")[0].strip()
!             elif "```" in content:
!                 json_str = content.split("```")[1].split("```")[0].strip()
!             else:
!                 json_str = content.strip()
  
!             result = json.loads(json_str)
  
              # Validate category_id
!             category_id = result.get("category_id")
!             if category_id not in [c.category_id for c in self.categories]:
!                 logger.warning(f"Invalid category ID {category_id} returned, using default")
!                 category_id = self.default_category_id
!                 result["category_id"] = category_id
!                 result["confidence"] = 0.5
  
!             return result
  
!         except Exception as e:
!             logger.exception(f"Anthropic categorization failed for: {post_title}")
!             return {
!                 "category_id": self.default_category_id,
!                 "confidence": 0.0,
!                 "reasoning": f"Error: {e!s}",
!             }
  
!     async def categorize_with_openai(self, post_title: str) -> dict[str, Any]:
!         """
!         Categorize post using OpenAI
  
!         Args:
!             post_title: Post title
  
!         Returns:
!             Dict with category_id, confidence, reasoning
!         """
!         if not self.openai_client:
!             raise ValueError("OpenAI client not initialized")
  
!         try:
!             prompt = self._build_categorization_prompt(post_title)
  
!             response = self.openai_client.chat.completions.create(
!                 model="gpt-4",
!                 messages=[{"role": "user", "content": prompt}],
!                 temperature=0.3,
!                 max_tokens=200,
!                 response_format={"type": "json_object"},
!             )
  
!             content = response.choices[0].message.content
!             import json
  
!             result = json.loads(content)
  
              # Validate category_id
!             category_id = result.get("category_id")
!             if category_id not in [c.category_id for c in self.categories]:
!                 logger.warning(f"Invalid category ID {category_id} returned, using default")
!                 category_id = self.default_category_id
!                 result["category_id"] = category_id
!                 result["confidence"] = 0.5
  
!             return result
  
!         except Exception as e:
!             logger.exception(f"OpenAI categorization failed for: {post_title}")
!             return {
!                 "category_id": self.default_category_id,
!                 "confidence": 0.0,
!                 "reasoning": f"Error: {e!s}",
!             }
  
!     def categorize_with_keywords(self, post_title: str) -> dict[str, Any]:
!         """
!         Fallback keyword-based categorization
  
!         Args:
!             post_title: Post title
  
!         Returns:
!             Dict with category_id, confidence, reasoning
!         """
!         logger.info(f"Using keyword matching for: {post_title}")
  
!         title_lower = post_title.lower()
!         best_match = None
!         best_score = 0
  
!         for category in self.categories:
!             score = sum(1 for keyword in category.keywords if keyword.lower() in title_lower)
  
!             if score > best_score:
!                 best_score = score
!                 best_match = category
  
!         if best_match and best_score > 0:
!             confidence = min(0.9, best_score * 0.3)  # Cap at 0.9 for keyword matching
!             return {
!                 "category_id": best_match.category_id,
!                 "confidence": confidence,
!                 "reasoning": f"Matched {best_score} keywords: {', '.join([k for k in best_match.keywords if k.lower() in title_lower])}",
!             }
!         else:
!             return {
!                 "category_id": self.default_category_id,
!                 "confidence": 0.2,
!                 "reasoning": "No keywords matched - using default category",
!             }
  
!     async def categorize_with_mcp(self, post_title: str) -> dict[str, Any]:
!         """
!         Categorize post using MCP tool calling
  
!         WHY: Use standardized MCP tool for token optimization
!         HOW: Invoke post_categorizer tool via MCP client
!         IMPACT: 98% token reduction vs. direct API calls
  
!         Args:
!             post_title: Post title to categorize
  
!         Returns:
!             Dict with category_id, category_name, confidence, reasoning
  
!         Raises:
!             MCPToolError: If MCP invocation fails
!         """
!         if not self.mcp_client:
!             raise MCPToolError("MCP client not initialized")
  
!         try:
              # Convert categories to format expected by MCP tool
!             available_categories = [
!                 {
!                     "id": cat.category_id,
!                     "name": cat.category_name,
!                     "slug": cat.category_name.lower().replace(" ", "-"),
!                     "description": f"Keywords: {', '.join(cat.keywords[:5])}",
!                 }
!                 for cat in self.categories
!             ]
  
              # Invoke MCP tool
!             result = await self.mcp_client.invoke_tool(
!                 tool_name="post_categorizer",
!                 category="wordpress_automation",
!                 inputs={
!                     "post_title": post_title,
!                     "available_categories": available_categories,
!                 },
!             )
  
!             logger.info(f"✅ MCP categorization: {result['category_name']} (confidence: {result['confidence']:.2f})")
!             return result
  
!         except MCPToolError as e:
!             logger.error(f"❌ MCP categorization failed: {e}")
!             raise
  
!     async def categorize_post(self, post_id: int, post_title: str, use_ai: bool = True) -> CategorizationResult:
!         """
!         Categorize a single WordPress post
  
!         WHY: Intelligently select best categorization method
!         HOW: Prefer MCP > Anthropic > OpenAI > Keywords
!         IMPACT: Token-optimized categorization with fallbacks
  
!         Args:
!             post_id: WordPress post ID
!             post_title: Post title
!             use_ai: Use AI categorization (True) or keyword matching (False)
  
!         Returns:
!             CategorizationResult
!         """
!         logger.info(f"Categorizing post {post_id}: {post_title}")
  
!         try:
              # Try AI categorization with intelligent fallback chain
!             if use_ai:
                  # Prefer MCP for token optimization
!                 if self.use_mcp and self.mcp_client:
!                     try:
!                         result = await self.categorize_with_mcp(post_title)
!                     except MCPToolError:
!                         logger.warning("⚠️  MCP failed, falling back to direct API")
!                         if self.anthropic_client:
!                             result = await self.categorize_with_anthropic(post_title)
!                         elif self.openai_client:
!                             result = await self.categorize_with_openai(post_title)
!                         else:
!                             result = self.categorize_with_keywords(post_title)
                  # Fallback to direct API calls
!                 elif self.anthropic_client:
!                     result = await self.categorize_with_anthropic(post_title)
!                 elif self.openai_client:
!                     result = await self.categorize_with_openai(post_title)
!                 else:
!                     result = self.categorize_with_keywords(post_title)
!             else:
!                 result = self.categorize_with_keywords(post_title)
  
              # Get category name
!             category = next(
!                 (c for c in self.categories if c.category_id == result["category_id"]),
!                 None,
!             )
!             category_name = category.category_name if category else "Unknown"
  
!             return CategorizationResult(
!                 post_id=post_id,
!                 post_title=post_title,
!                 assigned_category_id=result["category_id"],
!                 assigned_category_name=category_name,
!                 confidence=result.get("confidence", 0.5),
!                 reasoning=result.get("reasoning"),
!             )
  
!         except Exception as e:
!             logger.exception(f"Failed to categorize post {post_id}")
!             return CategorizationResult(
!                 post_id=post_id,
!                 post_title=post_title,
!                 assigned_category_id=self.default_category_id,
!                 assigned_category_name="Content Creation",
!                 confidence=0.0,
!                 error=str(e),
!             )
  
!     async def categorize_posts_batch(
!         self, posts: list[dict[str, Any]], use_ai: bool = True
!     ) -> list[CategorizationResult]:
!         """
!         Categorize multiple posts in batch
  
!         Args:
!             posts: List of post dicts with 'id' and 'title' keys
!             use_ai: Use AI categorization
  
!         Returns:
!             List of CategorizationResults
!         """
!         logger.info(f"Batch categorizing {len(posts)} posts")
  
!         results = []
!         for post in posts:
!             post_id = post.get("id")
!             post_title = post.get("title", {}).get("rendered", post.get("title", ""))
  
!             if not post_id or not post_title:
!                 logger.warning(f"Skipping post with missing id or title: {post}")
!                 continue
  
!             result = await self.categorize_post(post_id, post_title, use_ai)
!             results.append(result)
  
!         success_count = len([r for r in results if not r.error])
!         logger.info(f"Batch categorization complete: {success_count}/{len(results)} successful")
  
!         return results
  
!     def get_category_by_id(self, category_id: int) -> Optional[CategoryMapping]:
!         """Get category mapping by ID"""
!         return next((c for c in self.categories if c.category_id == category_id), None)
  
!     def get_all_categories(self) -> list[CategoryMapping]:
!         """Get all available categories"""
!         return self.categories
