> """
> Enterprise Database Configuration - SQLAlchemy Support
> Production-ready with Neon, Supabase, PlanetScale support
> """
  
! from collections.abc import AsyncGenerator
! import logging
! import os
  
! from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
! from sqlalchemy.ext.declarative import declarative_base
  
! from database_config import CONNECTION_ARGS, DATABASE_URL
  
  
! logger = logging.getLogger(__name__)
  
  # Create async engine with production-ready configuration
! engine = create_async_engine(
!     DATABASE_URL,
!     echo=os.getenv("DEBUG", "False") == "True",
!     future=True,
!     **CONNECTION_ARGS,
! )
  
  # Create async session factory
! AsyncSessionLocal = async_sessionmaker(
!     engine,
!     class_=AsyncSession,
!     expire_on_commit=False,
! )
  
  # Create base class for models
! Base = declarative_base()
  
  
! async def get_db() -> AsyncGenerator[AsyncSession, None]:
!     """
!     Provide a transactional async SQLAlchemy session for use as a dependency.
  
!     Yields:
!         AsyncSession: an active asynchronous SQLAlchemy session for database operations.
  
!     Raises:
!         DatabaseError: when an error occurs while using the session; the original exception is attached as `original_error`.
  
!     Notes:
!         The session is committed after normal use, rolled back on exception, and always closed when the generator exits.
!     """
!     async with AsyncSessionLocal() as session:
!         try:
!             yield session
!             await session.commit()
!         except Exception as e:
!             await session.rollback()
!             from core.exceptions import DatabaseError
  
!             raise DatabaseError("Database session error", original_error=e)
!         finally:
!             await session.close()
  
  
! async def init_db():
!     """
!     Initialize database - create all tables.
!     Call this on application startup.
!     """
!     async with engine.begin() as conn:
!         await conn.run_sync(Base.metadata.create_all)
  
  
! async def close_db():
!     """
!     Close database connections.
!     Call this on application shutdown.
!     """
!     await engine.dispose()
  
  
  # For backward compatibility with MongoDB code
! class DatabaseManager:
!     """
!     Compatibility layer for existing MongoDB code.
!     Provides similar interface to Motor/PyMongo.
!     """
  
!     def __init__(self):
!         self.engine = engine
!         self.session_factory = AsyncSessionLocal
!         self.connected = False
  
!     async def connect(self):
!         """
!         Initialize the database schema and mark this manager as connected.
  
!         Attempts to create all ORM tables via init_db(); on success sets `self.connected = True`
!         and returns a status dictionary. On failure logs the error and returns a failure status
!         dictionary containing the error message.
  
!         Returns:
!             status (dict): On success: {"status": "connected", "type": "SQLAlchemy", "url": DATABASE_URL}.
!                            On failure: {"status": "failed", "error": "<error message>"}.
!         """
!         try:
!             await init_db()
!             self.connected = True
!             return {"status": "connected", "type": "SQLAlchemy", "url": DATABASE_URL}
!         except Exception as e:
!             logger.error(f"Database connection failed: {e}")
!             return {"status": "failed", "error": str(e)}
  
!     async def disconnect(self):
!         """
!         Close and dispose the underlying database engine connections and mark the manager as disconnected.
!         """
!         await close_db()
!         self.connected = False
  
!     async def get_session(self) -> AsyncSession:
!         """Get a new database session"""
!         return AsyncSessionLocal()
  
!     def get_database(self):
!         """For compatibility - returns self"""
!         return self
  
!     async def health_check(self):
!         """
!         Perform a lightweight connectivity check against the configured database.
  
!         Returns:
!             dict: A status dictionary with the following keys:
!                 - status (str): "healthy" on success, "unhealthy" on failure.
!                 - connected (bool): True if the check succeeded, False otherwise.
!                 - type (str): Database backend type when healthy (e.g., "SQLAlchemy").
!                 - url (str): Host portion of DATABASE_URL when healthy, or "sqlite" for local SQLite.
!                 - error (str): Error message present only when the check failed.
!         """
!         try:
!             from sqlalchemy import text
  
!             async with AsyncSessionLocal() as session:
!                 await session.execute(text("SELECT 1"))
!                 return {
!                     "status": "healthy",
!                     "connected": True,
!                     "type": "SQLAlchemy",
!                     "url": (DATABASE_URL.split("@")[-1] if "@" in DATABASE_URL else "sqlite"),
!                 }
!         except Exception as e:
!             logger.warning(f"Database health check failed: {e}")
!             return {"status": "unhealthy", "connected": False, "error": str(e)}
  
  
  # Global database instance
! db_manager = DatabaseManager()
