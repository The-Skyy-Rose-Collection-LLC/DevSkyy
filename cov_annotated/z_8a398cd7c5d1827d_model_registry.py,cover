! from datetime import datetime
! from enum import Enum
! import json
! import logging
! from pathlib import Path
! from typing import Any, Optional
  
! import joblib
  
  
! """
! ML Model Registry using MLflow
! Manages model versioning, metadata, and lifecycle
  
! References:
! - MLflow Documentation: https://mlflow.org/docs/latest/
! - ML Model Management Best Practices: Google's ML Best Practices
! - Versioning: Semantic Versioning 2.0.0 (https://semver.org/)
! """
  
! logger = logging.getLogger(__name__)
  
  
! class ModelStage(str, Enum):
!     """Model lifecycle stages following MLflow convention"""
  
!     DEVELOPMENT = "development"
!     STAGING = "staging"
!     PRODUCTION = "production"
!     ARCHIVED = "archived"
  
  
! class ModelMetadata:
!     """Model metadata container"""
  
!     def __init__(
!         self,
!         model_name: str,
!         version: str,
!         model_type: str,
!         framework: str,
!         created_at: datetime,
!         metrics: dict[str, float],
!         parameters: dict[str, Any],
!         dataset_info: dict[str, Any],
!         stage: ModelStage = ModelStage.DEVELOPMENT,
!     ):
!         self.model_name = model_name
!         self.version = version
!         self.model_type = model_type
!         self.framework = framework
!         self.created_at = created_at
!         self.metrics = metrics
!         self.parameters = parameters
!         self.dataset_info = dataset_info
!         self.stage = stage
!         self.updated_at = created_at
  
!     def to_dict(self) -> dict[str, Any]:
!         """Convert metadata to dictionary"""
!         return {
!             "model_name": self.model_name,
!             "version": self.version,
!             "model_type": self.model_type,
!             "framework": self.framework,
!             "created_at": self.created_at.isoformat(),
!             "updated_at": self.updated_at.isoformat(),
!             "metrics": self.metrics,
!             "parameters": self.parameters,
!             "dataset_info": self.dataset_info,
!             "stage": self.stage,
!         }
  
!     @classmethod
!     def from_dict(cls, data: dict[str, Any]) -> "ModelMetadata":
!         """Create metadata from dictionary"""
!         return cls(
!             model_name=data["model_name"],
!             version=data["version"],
!             model_type=data["model_type"],
!             framework=data["framework"],
!             created_at=datetime.fromisoformat(data["created_at"]),
!             metrics=data["metrics"],
!             parameters=data["parameters"],
!             dataset_info=data["dataset_info"],
!             stage=data.get("stage", ModelStage.DEVELOPMENT),
!         )
  
  
! class ModelRegistry:
!     """
!     ML Model Registry for version management and lifecycle
  
!     Implements best practices from:
!     - Google's ML Engineering Best Practices
!     - MLflow Model Registry design patterns
!     - Semantic Versioning 2.0.0
!     """
  
!     def __init__(self, registry_path: str = "./ml/registry"):
!         """
!         Initialize model registry
  
!         Args:
!             registry_path: Base path for model storage
!         """
!         self.registry_path = Path(registry_path)
!         self.registry_path.mkdir(parents=True, exist_ok=True)
  
!         self.models_dir = self.registry_path / "models"
!         self.models_dir.mkdir(exist_ok=True)
  
!         self.metadata_dir = self.registry_path / "metadata"
!         self.metadata_dir.mkdir(exist_ok=True)
  
!         self.index_file = self.registry_path / "index.json"
!         self._load_index()
  
!         logger.info(f"ðŸ“¦ Model Registry initialized at {self.registry_path}")
  
!     def _load_index(self):
!         """Load registry index"""
!         if self.index_file.exists():
!             with open(self.index_file, "r") as f:
!                 self.index = json.load(f)
!         else:
!             self.index = {"models": {}, "version": "1.0.0"}
!             self._save_index()
  
!     def _save_index(self):
!         """Save registry index"""
!         with open(self.index_file, "w") as f:
!             json.dump(self.index, f, indent=2)
  
!     def register_model(
!         self,
!         model: Any,
!         model_name: str,
!         version: str,
!         model_type: str,
!         framework: str,
!         metrics: dict[str, float],
!         parameters: dict[str, Any],
!         dataset_info: dict[str, Any],
!         stage: ModelStage = ModelStage.DEVELOPMENT,
!     ) -> ModelMetadata:
!         """
!         Register a new model version
  
!         Args:
!             model: The trained model object
!             model_name: Name of the model
!             version: Semantic version (e.g., "1.0.0")
!             model_type: Type of model (e.g., "classifier", "regressor")
!             framework: Framework used (e.g., "scikit-learn", "tensorflow")
!             metrics: Performance metrics dict
!             parameters: Model hyperparameters
!             dataset_info: Information about training data
!             stage: Model lifecycle stage
  
!         Returns:
!             ModelMetadata object
!         """
          # Create metadata
!         metadata = ModelMetadata(
!             model_name=model_name,
!             version=version,
!             model_type=model_type,
!             framework=framework,
!             created_at=datetime.now(),
!             metrics=metrics,
!             parameters=parameters,
!             dataset_info=dataset_info,
!             stage=stage,
!         )
  
          # Save model
!         model_dir = self.models_dir / model_name / version
!         model_dir.mkdir(parents=True, exist_ok=True)
  
!         model_file = model_dir / "model.pkl"
!         joblib.dump(model, model_file)
  
          # Save metadata
!         metadata_file = self.metadata_dir / f"{model_name}_{version}.json"
!         with open(metadata_file, "w") as f:
!             json.dump(metadata.to_dict(), f, indent=2)
  
          # Update index
!         if model_name not in self.index["models"]:
!             self.index["models"][model_name] = {
!                 "versions": [],
!                 "latest_production": None,
!             }
  
!         version_entry = {
!             "version": version,
!             "stage": stage,
!             "created_at": metadata.created_at.isoformat(),
!             "metrics": metrics,
!         }
  
!         self.index["models"][model_name]["versions"].append(version_entry)
  
          # Update latest production if applicable
!         if stage == ModelStage.PRODUCTION:
!             self.index["models"][model_name]["latest_production"] = version
  
!         self._save_index()
  
!         logger.info(f"âœ… Registered {model_name} v{version} ({stage})")
!         logger.info(f"   Metrics: {metrics}")
  
!         return metadata
  
!     def load_model(
!         self,
!         model_name: str,
!         version: Optional[str] = None,
!         stage: Optional[ModelStage] = None,
!     ) -> Any:
!         """
!         Load a model from registry
  
!         Args:
!             model_name: Name of model to load
!             version: Specific version (if None, uses latest production)
!             stage: Load latest model in this stage
  
!         Returns:
!             Loaded model object
!         """
!         if version is None:
!             if stage:
!                 version = self._get_latest_version_by_stage(model_name, stage)
!             else:
!                 version = self.index["models"].get(model_name, {}).get("latest_production")
  
!             if not version:
!                 raise ValueError(f"No production version found for {model_name}")
  
!         model_file = self.models_dir / model_name / version / "model.pkl"
  
!         if not model_file.exists():
!             raise FileNotFoundError(f"Model file not found: {model_file}")
  
!         model = joblib.load(model_file)
  
!         logger.info(f"ðŸ“¥ Loaded {model_name} v{version}")
  
!         return model
  
!     def get_metadata(self, model_name: str, version: str) -> ModelMetadata:
!         """Get model metadata"""
!         metadata_file = self.metadata_dir / f"{model_name}_{version}.json"
  
!         if not metadata_file.exists():
!             raise FileNotFoundError(f"Metadata not found for {model_name} v{version}")
  
!         with open(metadata_file, "r") as f:
!             data = json.load(f)
  
!         return ModelMetadata.from_dict(data)
  
!     def list_models(self) -> list[str]:
!         """List all registered model names"""
!         return list(self.index["models"].keys())
  
!     def list_versions(self, model_name: str) -> list[dict[str, Any]]:
!         """List all versions of a model"""
!         if model_name not in self.index["models"]:
!             return []
  
!         return self.index["models"][model_name]["versions"]
  
!     def promote_model(self, model_name: str, version: str, target_stage: ModelStage):
!         """
!         Promote model to a different stage
  
!         Args:
!             model_name: Model name
!             version: Version to promote
!             target_stage: Target lifecycle stage
!         """
          # Update metadata
!         metadata = self.get_metadata(model_name, version)
!         metadata.stage = target_stage
!         metadata.updated_at = datetime.now()
  
!         metadata_file = self.metadata_dir / f"{model_name}_{version}.json"
!         with open(metadata_file, "w") as f:
!             json.dump(metadata.to_dict(), f, indent=2)
  
          # Update index
!         for version_entry in self.index["models"][model_name]["versions"]:
!             if version_entry["version"] == version:
!                 version_entry["stage"] = target_stage
!                 break
  
!         if target_stage == ModelStage.PRODUCTION:
!             self.index["models"][model_name]["latest_production"] = version
  
!         self._save_index()
  
!         logger.info(f"ðŸš€ Promoted {model_name} v{version} to {target_stage}")
  
!     def archive_model(self, model_name: str, version: str):
!         """Archive a model version"""
!         self.promote_model(model_name, version, ModelStage.ARCHIVED)
  
!     def compare_models(self, model_name: str, version1: str, version2: str) -> dict[str, Any]:
!         """
!         Compare two model versions
  
!         Returns:
!             Comparison dictionary with metrics diff
!         """
!         meta1 = self.get_metadata(model_name, version1)
!         meta2 = self.get_metadata(model_name, version2)
  
          # Calculate metric differences
!         metric_diff = {}
!         for metric_name in set(meta1.metrics.keys()) | set(meta2.metrics.keys()):
!             val1 = meta1.metrics.get(metric_name, 0)
!             val2 = meta2.metrics.get(metric_name, 0)
!             metric_diff[metric_name] = {
!                 "v1": val1,
!                 "v2": val2,
!                 "diff": val2 - val1,
!                 "improvement": ((val2 - val1) / val1 * 100) if val1 != 0 else 0,
!             }
  
!         return {
!             "model_name": model_name,
!             "version1": version1,
!             "version2": version2,
!             "metrics_comparison": metric_diff,
!             "stage1": meta1.stage,
!             "stage2": meta2.stage,
!         }
  
!     def _get_latest_version_by_stage(self, model_name: str, stage: ModelStage) -> Optional[str]:
!         """Get latest version in a specific stage"""
!         if model_name not in self.index["models"]:
!             return None
  
!         versions = self.index["models"][model_name]["versions"]
  
          # Filter by stage and sort by creation date
!         stage_versions = [v for v in versions if v["stage"] == stage]
  
!         if not stage_versions:
!             return None
  
          # Return most recent
!         latest = max(stage_versions, key=lambda x: x["created_at"])
!         return latest["version"]
  
!     def get_registry_stats(self) -> dict[str, Any]:
!         """Get registry statistics"""
!         total_models = len(self.index["models"])
!         total_versions = sum(len(m["versions"]) for m in self.index["models"].values())
  
!         stage_counts = dict.fromkeys(ModelStage, 0)
  
!         for model_info in self.index["models"].values():
!             for version in model_info["versions"]:
!                 stage_counts[version["stage"]] += 1
  
!         return {
!             "total_models": total_models,
!             "total_versions": total_versions,
!             "stage_distribution": stage_counts,
!             "models": list(self.index["models"].keys()),
!         }
  
  
  # Global registry instance
! model_registry = ModelRegistry()
  
  
! def get_model_registry() -> ModelRegistry:
!     """Get global model registry instance"""
!     return model_registry
