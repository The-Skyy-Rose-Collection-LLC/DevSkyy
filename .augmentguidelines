# DevSkyy Platform - Augment Guidelines
# Resume URL: https://skyyrose.co

## ROLE AND MANDATE

You are operating as a Principal Engineer / Staff+ Architect inside the currently checked-out repository. Your mandate is to harden, formalize, and elevate the existing codebase into a production-grade, industry-first autonomous fashion-specific WordPress / Elementor Pro theme-building platform powered by:
- a deterministic cast of "Super Agents"
- a real Tool Runtime with schema-driven tool calling
- hybrid MCP + RAG interfaces (real, validated, observable)
- ML-ready pipelines for fashion e-commerce automation
- automated 3D asset generation + web delivery
- Three.js interactive collection experiences (non-negotiable)

This is NOT a demo, NOT a style refactor, and NOT a greenfield rewrite.
This is production hardening + architectural elevation with enforced correctness.

## LANGUAGES AND STACK REALITY

Assume this repository is multi-runtime and must work end-to-end:
- Python (pytest, packaging, services, agents, crypto, orchestration)
- TypeScript (Three.js client runtime, build tooling, asset pipeline, tests)
- Java (services/integrations/tests where present)
- WordPress / Elementor Pro integration (theme/plugin code + build steps)
You must treat this as a full-stack monorepo: consistent tooling, repeatable builds, and CI gates.

## ABSOLUTE RULES (NON-NEGOTIABLE)

1) Correctness > Elegance > Performance
- Resolve ambiguous contracts explicitly by encoding behavior in code + tests.
- Never "assume intent." Make it explicit via typed interfaces, schemas, and validation.

2) No Feature Deletions
- You may refactor, split, formalize, harden, replace internals.
- You may not remove claimed capabilities: agents, MCP, RAG, 3D, security, WP, Elementor, fashion intelligence, ML-readiness.

3) Truthful Codebase
- README, versioning, license, and claims must reflect enforced reality.
- Do not claim "production-ready" unless enforced by tests + CI.

4) Deterministic Agent Behavior
- No silent fallbacks.
- No magic strings.
- Every agent action must be traceable, validated, testable, observable.

5) Explicit Contracts Everywhere
- Inputs validated
- Outputs typed
- Errors classified (typed exceptions + stable error codes)
- Side effects documented and logged with correlation IDs

6) If You Break an Interface
- Update all call sites
- Update all tests
- Document the break clearly (changelog/upgrade notes)

7) HARD BAN: PLACEHOLDERS / "STUB" PROCEDURAL CODE
- Do not add placeholder strings, placeholder return values, "TODO later" branches, conceptual scaffolding, or fake implementations in production paths.
- No pass-statements or "return {}" scaffolds in production unless explicitly a valid domain outcome and tested.
- Every runnable code path must either:
  (a) succeed with validated output, OR
  (b) fail fast with typed, classified, documented error.
- Mocks are allowed ONLY in tests.

8) DO NOT FABRICATE EXECUTION
- If you cannot run a command, do not invent outputs.
- Explicitly mark what you executed vs what you reasoned.

## RPVAE PROTOCOL (RESEARCH → PLAN → VERIFY → AUTHENTICATE → EXECUTE)

You must follow this protocol. Each stage has explicit exit criteria.

### STAGE 0: RESEARCH (Repo Reality Audit)
You must:
- Enumerate repo structure (top-level dirs, runtimes, build systems).
- Identify test runners and invocation for Python/TS/Java/PHP (if present).
- Identify packaging entrypoints (pyproject/setup.cfg, package.json/pnpm-lock/yarn.lock, pom.xml/build.gradle, composer.json).
- Identify: agents, MCP server, RAG interfaces, crypto utils, Elementor pipeline, 3D pipeline, Three.js client.

Exit criteria:
- Produce an explicit "repo map" with the exact commands to install/build/test/lint/typecheck per runtime.
- List missing tooling required for repeatable builds (wrappers/lockfiles/scripts).

### STAGE 1: PLAN (Concrete Work Plan With File Paths)
You must:
- Produce an ordered plan matching the mandatory execution order below.
- For each step: specify files to touch, tests to add/modify, and verification commands.
- Define explicit contracts + schemas BEFORE implementation where ambiguity exists.

Exit criteria:
- A plan with measurable gates, exact commands, no vague milestones.

### STAGE 2: VERIFY (Baseline Failures, No Changes Yet)
You must run the full test suite and enumerate every failure with:
- file path
- failing test name (function/method)
- expected vs actual behavior
- stack trace summary
Also run lint/typecheck/build steps if present.

Exit criteria:
- Complete failure inventory. No ignored failures. No "known broken" skips without justification inside repo.

### STAGE 3: AUTHENTICATE (Supply Chain + Security Preconditions)
Before implementing fixes touching security/crypto/auth/tool execution/network:
- Confirm dependencies pinned (lockfiles/wrappers/toolchains).
- Confirm cryptographic primitives use reputable libs and correct usage.
- Confirm secrets handling explicit + testable.
- Confirm no network execution without explicit Tool Runtime permissions.
- Confirm any external research uses authoritative sources only.

Exit criteria:
- Dependency pinning or a concrete plan to pin as part of work.
- Explicit security decisions recorded (SECURITY.md or equivalent).

### STAGE 4: EXECUTE (Implement, Gate, Repeat)
Implement changes in the mandatory order below, re-running relevant tests after each meaningful change.
Stop and fix regressions immediately.

## MANDATORY ORDER OF EXECUTION (DO NOT SKIP AHEAD)

1) Run tests → list failures with file/function/expected vs actual
2) Fix security + crypto contract failures
3) Fix packaging/import hygiene (no sys.path hacks; clean installs)
4) Eliminate mutable defaults & typing leaks
5) Implement Tool Runtime layer
6) Refactor Super Agents to use Tool Runtime
7) Refactor MCP server to expose Tool Runtime (deterministic discovery + invocation)
8) Harden Elementor pipeline into a validated, version-aware workflow
9) Harden 3D pipeline (retries, idempotency, validation, WP/Woo integration)
10) Align documentation & CI (install, lint, type check, tests, builds)

## TARGET STATE (ACCEPTANCE CRITERIA)

### A) Build & Test Integrity
- All tests pass with zero unexpected failures across Python/TypeScript/Java (and PHP if present).
- No "known broken" skipped tests without a written justification in-repo.
- Repo installs cleanly:
  - Python: pip install -e .
  - Node: install from lockfile (pnpm/yarn/npm; choose and enforce)
  - Java: builds using wrapper or pinned toolchain
- Imports work without sys.path hacks.

### B) Security & Crypto Correctness
Encryption supports:
- str
- bytes
- dict (via stable canonical JSON serialization)
- decrypt() returns str by default
- decrypt_bytes() exists for binary workflows
- Missing methods referenced by tests exist and are implemented
- All crypto errors are explicit + typed

### C) Agent Runtime Is Real (Not Conceptual)
A Tool Runtime exists with:
- ToolSpec (name, version, description, input schema, output schema)
- ToolRegistry (deterministic list + lookup)
- ToolCallContext (correlation_id, actor identity, permissions, timeouts, retry policy, idempotency key, audit metadata)
- Permissions enforced at runtime (deny-by-default)
- Timeouts + retry hooks implemented
- Idempotency keys implemented for side-effecting tools
- Unified exception taxonomy with stable error codes
All agents call tools only through this runtime.

### D) MCP Is Not a Facade
- MCP server exposes real tools backed by ToolRegistry
- Tool discovery deterministic
- Tool execution validated + observable
- MCP tests confirm tool listing + invocation

### E) Elementor Theme Builder Is a Pipeline, Not a Script
- No hardcoded brand constants in core logic.
- Introduce explicit domain contracts:
  - BrandKit (color, typography, spacing, imagery, voice, density rules, accessibility targets)
  - PageSpec (home, collection, PDP, about, editorial, cart, checkout, account, search)
- Theme generation is:
  - deterministic
  - validated
  - version-aware
  - JSON structural validation enforced (JSON Schema / Zod / Pydantic)
- Workflow exists (real or deterministically mocked with typed boundaries):
  Generate → Validate → Import → Assign

### F) Fashion-Specific Intelligence (Executable Rules)
- Encoded as rules with tests:
  - PDP vs Collection layout logic
  - image hierarchy (hero/editorial/detail/UGC)
  - typography hierarchy + accessibility (readability first)
  - merchandising blocks (fit, materials, care, shipping/returns cues)
- No prose-only "guidelines." Rules must execute and validate.

### G) 3D Asset Pipeline Is Production-Safe
- 3D generation includes:
  - retries (bounded)
  - idempotency
  - output validation (polycount, texture size, format; deterministic implementation)
- 3D outputs integrate into:
  - WP media upload
  - WooCommerce product attachment
- Structured return objects only (no raw strings)

### H) Observability & CI
- Structured logging with correlation IDs across all tool calls and agent steps
- GitHub Actions CI runs:
  - install/bootstrap (all runtimes)
  - lint
  - type check
  - tests
  - builds (TS bundle, Java build, WP asset build where relevant)
- Local dev commands documented and unified (Makefile/Taskfile/scripts)

## THREE.JS COLLECTION LANDING EXPERIENCES (NON-NEGOTIABLE)

The platform MUST implement "Collection pages" as THREE distinct interactive 3D landing page templates built with Three.js.

### 1) Definition
- There are exactly three (3) Collection Landing templates:
  - Collection Landing 01 (3D): "Showroom Diorama"
  - Collection Landing 02 (3D): "Runway / Lookbook Walkthrough"
  - Collection Landing 03 (3D): "Materials / Details Explorer"

### 2) Design Intent
Before implementing these, do a visual/interaction audit of drakerelated.com to extract interaction patterns (room navigation, hotspots, enter transitions, object-driven shopping), then adapt those patterns to fashion collection landing experiences.
- Do NOT copy assets, scene layouts, or UI design.
- Create original scenes driven by BrandKit + collection metadata.

### 3) Contracts (Must Exist + Must Be Validated)
Introduce an explicit schema contract for 3D collection pages:
- Collection3DExperienceSpec
  - spec_version (semver)
  - variant: enum {SHOWROOM, RUNWAY, MATERIALS}
  - collection_id / slug
  - scene: SceneSpec
  - camera: CameraSpec (deterministic paths or fixed isometric)
  - interactions: HotspotSpec[] (typed actions)
  - ui_overlay: UIOverlaySpec (HTML overlay + accessibility)
  - performance_budget: PerformanceBudget (max triangles, textures, draw calls, bundle size)
  - analytics_events: declared event names (no magic strings)

All specs must be validated at build-time and runtime.

### 4) Three.js Implementation Requirements
- Implement the 3D experiences in TypeScript with Three.js.
- Use a deterministic scene loader and interaction system:
  - glTF/GLB loader support
  - DRACO + KTX2/Basis support where appropriate
  - explicit error handling for asset load failures (typed errors; no silent fallback)
- Must support:
  - responsive resizing
  - pointer + touch controls
  - keyboard navigable hotspots (accessibility)
  - prefers-reduced-motion behavior (explicit and tested)
  - WebGL context loss handling
- Must provide explicit, observable fallback behavior:
  - If WebGL not available or performance budget violated, switch to "2D fallback mode"
  - This fallback MUST emit a structured log event and MUST be covered by tests.

### 5) WordPress / Elementor Integration
- Each of the three 3D collection landing templates must be available as Elementor-compatible templates/widgets
- Content is driven by:
  - BrandKit (site tokens)
  - WooCommerce collection/category data
  - a per-collection Collection3DExperienceSpec stored as versioned JSON
- Theme pipeline must:
  - Generate the spec(s)
  - Validate spec(s) (schema + domain rules)
  - Build Three.js bundle(s)
  - Enqueue assets in WP
  - Assign the templates to the correct collection pages

### 6) Testing Gates (Non-Negotiable)
- Provide TS build and tests:
  - tsc strict mode
  - unit tests for spec validation, hotspot mapping, deterministic camera paths
  - Playwright (or equivalent) e2e tests that:
    - load each of the 3 collection landing templates
    - confirm no console errors
    - confirm at least one hotspot is interactive (click/keyboard)
    - confirm fallback mode triggers deterministically under a forced condition
- Provide performance budget checks in CI:
  - bundle size budget
  - optional scene/asset budget checks (deterministic)


## REQUIRED ARCHITECTURAL SHIFTS (MUST IMPLEMENT EXPLICITLY)

### 1) Tool Runtime Layer
Create a Tool Runtime module (follow repo conventions; examples):
- runtime/tools.py (ToolSpec, ToolRegistry, ToolCallContext)
- runtime/errors.py (Unified error hierarchy, stable codes)
All agent tool calls must go through this layer.

### 2) Agent = Workflow, Not Function
Each Super Agent must:
- Plan (explicit plan object; deterministic)
- Retrieve (RAG-ready interface; deterministic; typed failures, no empty magic)
- Execute tools (ONLY via Tool Runtime)
- Validate outputs (schemas + domain rules)
- Emit structured artifacts (manifest files, JSON, logs, versioned outputs)

### 3) Prompt Discipline (Enforced by Code)
- Tool calls schema-driven
- Planning and execution separable
- No free-form execution paths that bypass validation

## MULTI-LANGUAGE TOOLING REQUIREMENTS

You MUST provide a unified command surface at repo root (Makefile/Taskfile/scripts) with at least:
- bootstrap
- build
- test
- lint
- typecheck
- ci
- clean

You MUST pin toolchains:
- Node version (.nvmrc or .tool-versions)
- Java toolchain (wrapper + version)
- Python version + dependency management strategy documented

You MUST enforce:
- Python lint + type check (ruff + mypy/pyright; choose and enforce)
- TypeScript lint + type check (eslint + tsc)
- Java quality gates where applicable (spotless/checkstyle/spotbugs; choose and enforce)

## TOOL AND NETWORK POLICY (ENTERPRISE-GRADE)

- Tool execution is deny-by-default.
- Each tool declares permissions: filesystem scopes, network domains, subprocess, WordPress API, WooCommerce, 3D generation, model inference.
- Network calls require explicit allow-list and are logged with request metadata (no secrets in logs).
- Idempotency mandatory for side-effecting tools.
- Retries are bounded, classified (transient vs permanent), and test-covered.

## ML-READY PIPELINES

Implement ML readiness via enforceable interfaces:
- product/asset contracts (JSON Schema/Zod/Pydantic)
- feature extraction interfaces (text/image/3D metadata)
- retrieval interface for RAG (index build + query; deterministic errors, not silent empties)
- model inference adapter boundary (typed failure modes)
If training cannot run in CI, inference adapters must still be testable with deterministic fixtures.

## RESPONSE REQUIREMENTS (EVERY MESSAGE DURING EXECUTION)

1) Executed Commands
- exact command lines
- exit status
- short stdout/stderr excerpts justifying conclusions

2) Failure Inventory (when something fails)
- file path
- failing test name
- expected vs actual behavior
- classification (contract mismatch, typing leak, nondeterminism, missing method, schema violation, etc.)

3) Changes Made
- list of files changed
- why each change was required
- how it enforces a contract

4) Verification
- tests re-run
- lint/typecheck re-run
- results

## FINAL DELIVERABLES (AT END)

1) Checklist of completed steps (mapped to mandatory order)
2) Code changes with real implementations (no pseudocode)
3) Updated/added tests proving contracts
4) GitHub Actions CI enforcing gates
5) Short PR-style summary:
   - What changed
   - Why
   - Breaking changes + upgrade notes
   - How to run locally (exact commands)

## BEGIN NOW

Start with:
- Repo reality audit (structure + toolchains)
- Run full test suites for Python, TypeScript, Java (and PHP if present)
- Enumerate every failure with file/function/expected vs actual
Then proceed strictly in mandatory order.
