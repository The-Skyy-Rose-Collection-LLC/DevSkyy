#!/usr/bin/env python3
"""
DevSkyy Vulnerability Remediation System
========================================

Automated vulnerability remediation with intelligent dependency management.
Safely updates dependencies while maintaining compatibility and functionality.

Features:
- Automated npm audit fix with compatibility checking
- Selective dependency updates based on severity
- Backup and rollback capabilities
- CI/CD integration
- Post-fix validation

Dependencies: subprocess, json, pathlib, shutil, typing
"""

import json
import logging
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)


class VulnerabilityRemediationAgent:
    """Automated vulnerability remediation with safety checks."""

    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.backup_dir = (
            project_root
            / "backups"
            / f"pre-security-fix-{datetime.now().strftime('%Y%m%d-%H%M%S')}"
        )

    def remediate_all_vulnerabilities(self, dry_run: bool = True) -> bool:
        """Perform comprehensive vulnerability remediation."""
        logger.info(f"Starting vulnerability remediation (dry_run={dry_run})...")

        if not dry_run:
            self._create_backup()

        success = True

        # Fix npm vulnerabilities
        if (self.project_root / "package.json").exists():
            npm_success = self._fix_npm_vulnerabilities(dry_run)
            success = success and npm_success

        # Fix Python vulnerabilities
        if (self.project_root / "requirements.txt").exists() or (
            self.project_root / "pyproject.toml"
        ).exists():
            python_success = self._fix_python_vulnerabilities(dry_run)
            success = success and python_success

        if not dry_run and success:
            # Validate fixes
            validation_success = self._validate_fixes()
            if not validation_success:
                logger.error("Post-fix validation failed, consider rollback")
                success = False

        return success

    def _create_backup(self) -> None:
        """Create backup of critical files before making changes."""
        logger.info(f"Creating backup at {self.backup_dir}")
        self.backup_dir.mkdir(parents=True, exist_ok=True)

        # Backup package files
        files_to_backup = [
            "package.json",
            "package-lock.json",
            "requirements.txt",
            "pyproject.toml",
            "poetry.lock",
        ]

        for file_name in files_to_backup:
            source = self.project_root / file_name
            if source.exists():
                target = self.backup_dir / file_name
                shutil.copy2(source, target)
                logger.info(f"Backed up {file_name}")

    def _fix_npm_vulnerabilities(self, dry_run: bool = True) -> bool:
        """Fix npm vulnerabilities using npm audit fix."""
        logger.info("Fixing npm vulnerabilities...")

        try:
            # First, try npm audit fix --dry-run to see what would be changed
            cmd = ["npm", "audit", "fix"]
            if dry_run:
                cmd.append("--dry-run")

            result = subprocess.run(
                cmd,
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minutes
            )

            if result.returncode == 0:
                logger.info("npm audit fix completed successfully")
                if not dry_run:
                    logger.info("Dependencies updated, running npm install to ensure consistency")
                    self._run_npm_install()
                return True
            else:
                logger.warning(f"npm audit fix had issues: {result.stderr}")
                # Try force fix for critical/high severity issues
                return self._force_fix_critical_npm_vulnerabilities(dry_run)

        except subprocess.TimeoutExpired:
            logger.error("npm audit fix timed out")
            return False
        except Exception as e:
            logger.error(f"npm audit fix failed: {e}")
            return False

    def _force_fix_critical_npm_vulnerabilities(self, dry_run: bool = True) -> bool:
        """Force fix critical and high severity npm vulnerabilities."""
        logger.info("Attempting force fix for critical/high severity vulnerabilities...")

        try:
            cmd = ["npm", "audit", "fix", "--force"]
            if dry_run:
                cmd.append("--dry-run")

            result = subprocess.run(
                cmd, cwd=self.project_root, capture_output=True, text=True, timeout=300
            )

            if result.returncode == 0:
                logger.info("Force fix completed successfully")
                return True
            else:
                logger.error(f"Force fix failed: {result.stderr}")
                return self._manual_fix_npm_vulnerabilities(dry_run)

        except Exception as e:
            logger.error(f"Force fix failed: {e}")
            return False

    def _manual_fix_npm_vulnerabilities(self, dry_run: bool = True) -> bool:
        """Manually fix specific npm vulnerabilities by updating packages."""
        logger.info("Attempting manual fixes for specific vulnerabilities...")

        # Known problematic packages that need manual intervention
        manual_fixes = {
            "@vue/cli": "5.0.8",  # Update to latest stable
            "braces": "3.0.3",  # Fix ReDoS vulnerability
            "micromatch": "4.0.8",  # Fix ReDoS vulnerability
            "http-cache-semantics": "4.1.1",  # Fix ReDoS vulnerability
        }

        if dry_run:
            logger.info("Would manually update the following packages:")
            for package, version in manual_fixes.items():
                logger.info(f"  {package}@{version}")
            return True

        success = True
        for package, version in manual_fixes.items():
            try:
                # Check if package exists in package.json
                if self._package_exists_in_dependencies(package):
                    logger.info(f"Updating {package} to {version}")
                    result = subprocess.run(
                        ["npm", "install", f"{package}@{version}"],
                        cwd=self.project_root,
                        capture_output=True,
                        text=True,
                        timeout=120,
                    )

                    if result.returncode != 0:
                        logger.error(f"Failed to update {package}: {result.stderr}")
                        success = False
                else:
                    logger.info(f"Package {package} not found in dependencies, skipping")

            except Exception as e:
                logger.error(f"Error updating {package}: {e}")
                success = False

        return success

    def _package_exists_in_dependencies(self, package_name: str) -> bool:
        """Check if package exists in package.json dependencies."""
        try:
            package_json_path = self.project_root / "package.json"
            with open(package_json_path) as f:
                package_data = json.load(f)

            dependencies = package_data.get("dependencies", {})
            dev_dependencies = package_data.get("devDependencies", {})

            return package_name in dependencies or package_name in dev_dependencies
        except Exception as e:
            logger.error(f"Error checking package dependencies: {e}")
            return False

    def _run_npm_install(self) -> bool:
        """Run npm install to ensure dependency consistency."""
        try:
            result = subprocess.run(
                ["npm", "install"],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=300,
            )

            if result.returncode == 0:
                logger.info("npm install completed successfully")
                return True
            else:
                logger.error(f"npm install failed: {result.stderr}")
                return False

        except Exception as e:
            logger.error(f"npm install error: {e}")
            return False

    def _fix_python_vulnerabilities(self, dry_run: bool = True) -> bool:
        """Fix Python vulnerabilities using pip-audit and updates."""
        logger.info("Fixing Python vulnerabilities...")

        try:
            # Check if pip-audit is available
            result = subprocess.run(
                ["pip-audit", "--version"], capture_output=True, text=True, timeout=10
            )

            if result.returncode != 0:
                logger.warning("pip-audit not available, installing...")
                if not dry_run:
                    subprocess.run(["pip", "install", "pip-audit"], check=True)

            # Run pip-audit with fix option
            cmd = ["pip-audit", "--fix"]
            if dry_run:
                cmd = ["pip-audit", "--format=json"]

            result = subprocess.run(
                cmd, cwd=self.project_root, capture_output=True, text=True, timeout=300
            )

            if result.returncode == 0:
                logger.info("Python vulnerability fixes completed")
                return True
            else:
                logger.warning(f"pip-audit fix had issues: {result.stderr}")
                return True  # Non-critical for now

        except FileNotFoundError:
            logger.warning("pip-audit not available, skipping Python vulnerability fixes")
            return True
        except Exception as e:
            logger.error(f"Python vulnerability fix failed: {e}")
            return False

    def _validate_fixes(self) -> bool:
        """Validate that fixes didn't break the application."""
        logger.info("Validating fixes...")

        validation_success = True

        # Test npm build
        if (self.project_root / "package.json").exists():
            npm_valid = self._validate_npm_build()
            validation_success = validation_success and npm_valid

        # Test Python imports
        if (self.project_root / "requirements.txt").exists() or (
            self.project_root / "pyproject.toml"
        ).exists():
            python_valid = self._validate_python_imports()
            validation_success = validation_success and python_valid

        return validation_success

    def _validate_npm_build(self) -> bool:
        """Validate npm build still works."""
        try:
            logger.info("Testing npm build...")
            result = subprocess.run(
                ["npm", "run", "build"],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=300,
            )

            if result.returncode == 0:
                logger.info("npm build validation passed")
                return True
            else:
                logger.error(f"npm build validation failed: {result.stderr}")
                return False

        except Exception as e:
            logger.error(f"npm build validation error: {e}")
            return False

    def _validate_python_imports(self) -> bool:
        """Validate critical Python imports still work."""
        try:
            logger.info("Testing Python imports...")

            # Test importing main modules
            test_modules = ["fastapi", "pydantic", "uvicorn"]

            for module_name in test_modules:
                try:
                    __import__(module_name)
                    logger.debug(f"Import successful: {module_name}")
                except ImportError as e:
                    logger.error(f"Import failed: {module_name} - {e}")
                    return False

            logger.info("Python import validation passed")
            return True

        except Exception as e:
            logger.error(f"Python import validation error: {e}")
            return False

    def rollback_changes(self) -> bool:
        """Rollback changes using backup."""
        if not self.backup_dir.exists():
            logger.error("No backup found for rollback")
            return False

        logger.info(f"Rolling back changes from {self.backup_dir}")

        try:
            # Restore backed up files
            for backup_file in self.backup_dir.iterdir():
                if backup_file.is_file():
                    target = self.project_root / backup_file.name
                    shutil.copy2(backup_file, target)
                    logger.info(f"Restored {backup_file.name}")

            # Reinstall dependencies
            if (self.project_root / "package.json").exists():
                self._run_npm_install()

            logger.info("Rollback completed successfully")
            return True

        except Exception as e:
            logger.error(f"Rollback failed: {e}")
            return False


def main():
    """Main entry point for vulnerability remediation."""
    import argparse

    parser = argparse.ArgumentParser(description="DevSkyy vulnerability remediation")
    parser.add_argument("--dry-run", action="store_true", help="Preview changes without executing")
    parser.add_argument("--execute", action="store_true", help="Execute the remediation")
    parser.add_argument("--rollback", action="store_true", help="Rollback previous changes")

    args = parser.parse_args()

    if not (args.dry_run or args.execute or args.rollback):
        parser.error("Must specify --dry-run, --execute, or --rollback")

    project_root = Path(__file__).parent.parent
    remediator = VulnerabilityRemediationAgent(project_root)

    if args.rollback:
        success = remediator.rollback_changes()
        sys.exit(0 if success else 1)

    success = remediator.remediate_all_vulnerabilities(dry_run=args.dry_run)

    if success:
        logger.info("Vulnerability remediation completed successfully")
        sys.exit(0)
    else:
        logger.error("Vulnerability remediation failed")
        sys.exit(1)


if __name__ == "__main__":
    main()
